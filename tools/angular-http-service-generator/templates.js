"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ANGULAR_SERVICE_FILE_CORE_TAIL = exports.ANGULAR_SERVICE_METHOD = exports.ANGULAR_SERVICE_NECESSARY_IMPORTS = exports.ANGULAR_SERVICE_FILE_CORE_HEAD = exports.ANGULAR_SERVICE_HEADER = void 0;
const path_1 = __importDefault(require("path"));
exports.ANGULAR_SERVICE_HEADER = `/**
 * This file is auto-generated by MonaXr tool.
 * Editing this file directly is NOT RECOMMENDED as it will be overwritten.
 * Generated files can be have mistakes. Please verify the generated code before using.
 * Generated on: ${new Date().toISOString()}
 */`;
const ANGULAR_SERVICE_FILE_CORE_HEAD = (className) => `
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class ${className} {
  constructor(private http: HttpClient) {}`;
exports.ANGULAR_SERVICE_FILE_CORE_HEAD = ANGULAR_SERVICE_FILE_CORE_HEAD;
const ANGULAR_SERVICE_NECESSARY_IMPORTS = (workDir, parentPackageName, methods) => {
    const importsMap = new Map();
    methods.forEach(method => {
        if (method.requestBody && method.requestBody.typeName && method.requestBody.importedFrom && typeImportAcceptable(method.requestBody.typeName, method.requestBody.importedFrom)) {
            const importedFrom = replaceWorkPathWithPackageName(method.requestBody.importedFrom, workDir, parentPackageName);
            if (!importsMap.has(importedFrom)) {
                importsMap.set(importedFrom, []);
            }
            importsMap.get(importedFrom).push(method.requestBody.typeName);
        }
        if (method.responseType && method.responseType.typeName && method.responseType.importedFrom && typeImportAcceptable(method.responseType.typeName, method.responseType.importedFrom)) {
            const importedFrom = replaceWorkPathWithPackageName(method.responseType.importedFrom, workDir, parentPackageName);
            if (!importsMap.has(importedFrom)) {
                importsMap.set(importedFrom, []);
            }
            importsMap.get(importedFrom).push(method.responseType.typeName);
        }
    });
    let importStrings = '';
    importsMap.forEach((typeNames, fromPath) => {
        importStrings += `import { ${[...new Set(typeNames)].join(', ')} } from '${fromPath}';\n`;
    });
    return importStrings;
};
exports.ANGULAR_SERVICE_NECESSARY_IMPORTS = ANGULAR_SERVICE_NECESSARY_IMPORTS;
const ANGULAR_SERVICE_METHOD = (restMethod) => {
    const httpMethod = restMethod.methodType.toLowerCase();
    const methodName = allCamelCase(httpMethod, restMethod.path.replace(/[-_\:\/]{1,}([a-zA-Z])/g, (_, p1) => p1.toUpperCase()));
    const url = restMethod.path;
    const ngMethodBodyParamString = restMethod.requestBody ? `requestBody: ${restMethod.requestBody.typeName}` : '';
    const ngMethodPathParameters = restMethod.pathParameters.map(param => `${param.parameterName}: ${param.typeName || "any"}`).join(', ');
    const ngMethodQueryParams = restMethod.queryParameters.map(param => `${param.parameterName}: ${param.typeName || "any"}`).join(', ');
    const queryParametersStringInMethod = restMethod.queryParameters.map(param => `\`${param.parameterName}=\${${param.parameterName}}\``).join(' + \'&\' + ');
    const urlPathParameterAltration = restMethod.pathParameters.map(param => `.replace(':${param.parameterName}', \`${param.parameterName}\`)`).join('');
    const urlAlteration = (urlPathParameterAltration) + (ngMethodQueryParams ? ` + '?' + ${queryParametersStringInMethod}` : '');
    return `
  ${methodName}(${[ngMethodPathParameters, ngMethodQueryParams, ngMethodBodyParamString].filter(x => x).join(', ')}): Observable<${restMethod.responseType?.typeName || 'any'}> {
    let urlAltered = "${url}"${urlAlteration};

    return this.http.${httpMethod}<${restMethod.responseType?.typeName || 'any'}>(urlAltered${restMethod.requestBody ? ', requestBody' : ''});
  }
`;
};
exports.ANGULAR_SERVICE_METHOD = ANGULAR_SERVICE_METHOD;
exports.ANGULAR_SERVICE_FILE_CORE_TAIL = `
}
`;
function replaceWorkPathWithPackageName(importPath, workDir, libraryPackageName) {
    const workingLibraryName = /libs[\/\\]([^\/\\]+)[\/\\]src[\/\\]lib/.exec(importPath)[0];
    let importPathAltered = importPath.replace(path_1.default.join(workDir, "libs", "src", "lib"), `@${libraryPackageName}/${workingLibraryName}`);
    return importPathAltered;
}
function allCamelCase(...args) {
    return args.map((str, index) => {
        if (index === 0) {
            return str.charAt(0).toLowerCase() + str.slice(1);
        }
        else {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }
    }).join('');
}
function typeImportAcceptable(typeName, importedFrom) {
    if (typeName === 'any' || typeName === 'void' || typeName === 'string' || typeName === 'number' || typeName === 'boolean' || typeName === 'unknown' || typeName === 'object'
        || typeName === 'Array' || typeName === 'Date' || typeName === "__type" || typeName === "__object") {
        return false;
    }
    if (importedFrom.startsWith('@nestjs')) {
        return false;
    }
    return true;
}
//# sourceMappingURL=templates.js.map