"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ANGULAR_SERVICE_FILE_CORE_TAIL = exports.ANGULAR_SERVICE_METHOD = exports.ANGULAR_SERVICE_NECESSARY_IMPORTS = exports.ANGULAR_SERVICE_FILE_CORE_HEAD = exports.ANGULAR_SERVICE_HEADER = void 0;
const typescript_utils_1 = require("../rest-doc-extractor/parser/typescript-utils");
exports.ANGULAR_SERVICE_HEADER = `/**
 * This file is auto-generated by MonaXr tool.
 * Generated files can be have mistakes. Please verify the generated code before using.
 * Feel free to feedback any issues to https://github.com/ubs-platform/ubs-mona-mr
 * Generated on: ${new Date().toISOString()}
 */`;
const ANGULAR_SERVICE_FILE_CORE_HEAD = (className, parentPath) => `
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class ${className} {
  readonly basePath = '${parentPath}';
  constructor(private http: HttpClient) {}
  
  interceptUrl(url: string): string {
    // you can modify url here if needed
    return this.basePath + url;
  }  
  
`;
exports.ANGULAR_SERVICE_FILE_CORE_HEAD = ANGULAR_SERVICE_FILE_CORE_HEAD;
const ANGULAR_SERVICE_NECESSARY_IMPORTS = (workDir, parentPackageName, methods) => {
    const importsMap = new Map();
    methods.forEach(method => {
        if (method.requestBody && method.requestBody.typeName && method.requestBody.importedFrom && typeImportAcceptable(method.requestBody.typeName, method.requestBody.importedFrom)) {
            pootis(importsMap, replaceWorkPathWithPackageName(method.requestBody.importedFrom, workDir, parentPackageName), method.requestBody.typeName);
        }
        if (method.responseType && method.responseType.typeName && method.responseType.importedFrom && typeImportAcceptable(method.responseType.typeName, method.responseType.importedFrom)) {
            const importedFrom = replaceWorkPathWithPackageName(method.responseType.importedFrom, workDir, parentPackageName);
            pootis(importsMap, importedFrom, method.responseType.typeName);
            const typeArguments = method.responseType.typeNode.getTypeArguments();
            typeArguments.forEach(ta => {
                const taTypeName = ta.getText();
                const taImportedFrom = typescript_utils_1.TypescriptNestUtils.findImportSource(ta);
                pootis(importsMap, replaceWorkPathWithPackageName(taImportedFrom, workDir, parentPackageName), taTypeName);
            });
        }
    });
    let importStrings = '';
    importsMap.forEach((typeNames, fromPath) => {
        importStrings += `import { ${[...new Set(typeNames)].join(', ')} } from '${fromPath}';\n`;
    });
    return importStrings;
};
exports.ANGULAR_SERVICE_NECESSARY_IMPORTS = ANGULAR_SERVICE_NECESSARY_IMPORTS;
const ANGULAR_SERVICE_METHOD = (restMethod) => {
    const httpMethod = restMethod.methodType.toLowerCase();
    const methodName = restMethod.methodName || allCamelCase(httpMethod, restMethod.path.replace(/[-_\:\/]{1,}([a-zA-Z])/g, (_, p1) => p1.toUpperCase()));
    const url = restMethod.path;
    let bodyType = 'any';
    if (restMethod.requestBody?.typeName == "__type" || restMethod.requestBody?.typeName == "__object" || restMethod.requestBody?.typeName.toLowerCase() == "array") {
        bodyType = restMethod.requestBody.typeExpandedText;
    }
    else if (restMethod.requestBody?.typeName) {
        bodyType = restMethod.requestBody.typeName || 'any';
    }
    const ngMethodBodyParamString = restMethod.requestBody ? `requestBody: ${bodyType}` : '';
    const ngMethodPathParameters = restMethod.pathParameters.map(param => `${param.parameterName}: ${param.typeName || "any"}`).join(', ');
    const ngMethodQueryParams = restMethod.queryParameters.map(param => `${param.parameterName}: ${param.typeName || "any"}`).join(', ');
    const queryParametersStringInMethod = restMethod.queryParameters.map(param => `\`${param.parameterName}=\${${param.parameterName}}\``).join(' + \'&\' + ');
    const urlPathParameterAltration = restMethod.pathParameters.map(param => `.replace(':${param.parameterName}', ${param.parameterName} + '')`).join('');
    const urlAlteration = (urlPathParameterAltration) + (ngMethodQueryParams ? ` + '?' + ${queryParametersStringInMethod}` : '');
    let responseType = 'any';
    if (restMethod.responseType?.typeName == "__type" || restMethod.responseType?.typeName == "__object" || restMethod.responseType?.typeName.toLowerCase() == "array") {
        responseType = restMethod.responseType.typeExpandedText;
    }
    else if (restMethod.responseType?.typeName) {
        responseType = restMethod.responseType.typeName || 'any';
    }
    return `
  ${methodName}(${[ngMethodPathParameters, ngMethodQueryParams, ngMethodBodyParamString].filter(x => x).join(', ')}): Observable<${responseType || 'any'}> {
    let urlAltered = this.interceptUrl("${url}"${urlAlteration});

    return this.http.${httpMethod}<${restMethod.responseType?.typeName || 'any'}>(urlAltered${restMethod.requestBody ? ', requestBody' : ''});
  }
`;
};
exports.ANGULAR_SERVICE_METHOD = ANGULAR_SERVICE_METHOD;
exports.ANGULAR_SERVICE_FILE_CORE_TAIL = `
}
`;
function pootis(importsMap, importedFrom, typName) {
    if (!importsMap.has(importedFrom)) {
        importsMap.set(importedFrom, []);
    }
    const typeName = typeNameAlone(typName);
    if (!importsMap.get(importedFrom).includes(typeName)) {
        importsMap.get(importedFrom).push(typeName);
    }
}
function typeNameAlone(tn) {
    return tn.replace("[]", "").replace(/<.*>/g, "").replace(/import\(".*"\)\./g, "");
}
function replaceWorkPathWithPackageName(importPath, workDir, libraryPackageName) {
    const workingLibraryName = /libs\/([a-zA-Z-_]*)/g.exec(importPath)?.[1];
    if (importPath.startsWith(workDir) && workingLibraryName) {
        return `${libraryPackageName}/${workingLibraryName}`;
    }
    return importPath;
}
function allCamelCase(...args) {
    return args.map((str, index) => {
        if (index === 0) {
            return str.charAt(0).toLowerCase() + str.slice(1);
        }
        else {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }
    }).join('');
}
function typeImportAcceptable(typeName, importedFrom) {
    if (typeName === 'any' || typeName === 'void' || typeName === 'string' || typeName === 'number' || typeName === 'boolean' || typeName === 'unknown' || typeName === 'object'
        || typeName === 'Date' || typeName === "__type" || typeName === "__object" || typeName.toLowerCase() === "array") {
        return false;
    }
    if (importedFrom.startsWith('@nestjs') || importedFrom.includes("apps/") || importedFrom.includes('node_modules/typescript/lib')) {
        return false;
    }
    return true;
}
//# sourceMappingURL=templates.js.map