import path from 'path';
import { RestApiMethod } from '../rest-doc-extractor/parser/api.data';

export const ANGULAR_SERVICE_HEADER = `/**
 * This file is auto-generated by MonaXr tool.
 * Editing this file directly is NOT RECOMMENDED as it will be overwritten.
 * Generated files can be have mistakes. Please verify the generated code before using.
 * Generated on: ${new Date().toISOString()}
 */`;

export const ANGULAR_SERVICE_FILE_CORE_HEAD = (className: string) => `
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class ${className} {
  constructor(private http: HttpClient) {}`;

export const ANGULAR_SERVICE_NECESSARY_IMPORTS = (workDir: string, parentPackageName: string, methods: RestApiMethod[]) => {
  const importsMap = new Map<string, string[]>();
  methods.forEach(method => {

    if (method.requestBody && method.requestBody.typeName && method.requestBody.importedFrom && typeImportAcceptable(method.requestBody.typeName, method.requestBody.importedFrom)) {
      const importedFrom = replaceWorkPathWithPackageName(method.requestBody.importedFrom, workDir, parentPackageName);

      if (!importsMap.has(importedFrom)) {
        importsMap.set(importedFrom, []);
      }
      importsMap.get(importedFrom)!.push(method.requestBody.typeName);
    }


    if (method.responseType && method.responseType.typeName && method.responseType.importedFrom && typeImportAcceptable(method.responseType.typeName, method.responseType.importedFrom)) {
      const importedFrom = replaceWorkPathWithPackageName(method.responseType.importedFrom, workDir, parentPackageName);

      if (!importsMap.has(importedFrom)) {
        importsMap.set(importedFrom, []);
      }
      importsMap.get(importedFrom)!.push(method.responseType.typeName);
    }
  });

  let importStrings = '';
  importsMap.forEach((typeNames, fromPath) => {
    importStrings += `import { ${[...new Set(typeNames)].join(', ')} } from '${fromPath}';\n`;
  });
  return importStrings;

  // collect from parameters too
  // if (method.requestBody &&
  // method.pathParameters.forEach(param => {
  //   if (param.typeName && param.importedFrom) {
  //     importsMap.set(param.typeName, param.importedFrom);
  //   }
  // });
  // method.queryParameters.forEach(param => {
  //   if (param.typeName && param.importedFrom) {
  //     importsMap.set(param.typeName, param.importedFrom);
  //   }
  // });

}

export const ANGULAR_SERVICE_METHOD = (restMethod: RestApiMethod) => {
  const httpMethod = restMethod.methodType.toLowerCase();
  const methodName = allCamelCase(httpMethod, restMethod.path.replace(/[-_\:\/]{1,}([a-zA-Z])/g, (_, p1) => p1.toUpperCase()));
  const url = restMethod.path;
  const ngMethodBodyParamString = restMethod.requestBody ? `requestBody: ${restMethod.requestBody.typeName}` : '';
  const ngMethodPathParameters = restMethod.pathParameters.map(param => `${param.parameterName}: ${param.typeName || "any"}`).join(', ');
  const ngMethodQueryParams = restMethod.queryParameters.map(param => `${param.parameterName}: ${param.typeName || "any"}`).join(', ');
  const queryParametersStringInMethod = restMethod.queryParameters.map(param => `\`${param.parameterName}=\${${param.parameterName}}\``).join(' + \'&\' + ');
  const urlPathParameterAltration = restMethod.pathParameters.map(param => `.replace(':${param.parameterName}', \`${param.parameterName}\`)`).join('');
  const urlAlteration = (urlPathParameterAltration) + (ngMethodQueryParams ? ` + '?' + ${queryParametersStringInMethod}` : '');

  return `
  ${methodName}(${[ngMethodPathParameters, ngMethodQueryParams, ngMethodBodyParamString].filter(x => x).join(', ')}): Observable<${restMethod.responseType?.typeName || 'any'}> {
    let urlAltered = "${url}"${urlAlteration};

    return this.http.${httpMethod}<${restMethod.responseType?.typeName || 'any'}>(urlAltered${restMethod.requestBody ? ', requestBody' : ''});
  }
`
};

export const ANGULAR_SERVICE_FILE_CORE_TAIL = `
}
`;
function replaceWorkPathWithPackageName(importPath: string, workDir: string, libraryPackageName: string) {
  const workingLibraryName = /libs\/([a-zA-Z-_]*)/g.exec(importPath)?.[1];
  if (importPath.startsWith(workDir) && workingLibraryName) {
    return `@${libraryPackageName}/${workingLibraryName}`;
  }
  return importPath;
}

function allCamelCase(...args: string[]): string {
  return args.map((str, index) => {
    if (index === 0) {
      return str.charAt(0).toLowerCase() + str.slice(1);
    } else {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }
  }).join('');

}

function typeImportAcceptable(typeName: string, importedFrom: string) {
  if (typeName === 'any' || typeName === 'void' || typeName === 'string' || typeName === 'number' || typeName === 'boolean' || typeName === 'unknown' || typeName === 'object'
    || typeName === 'Array' || typeName === 'Date' || typeName === "__type" || typeName === "__object"
  ) {
    return false;
  }
  if (importedFrom.startsWith('@nestjs')) {
    return false;
  }
  return true;
}

