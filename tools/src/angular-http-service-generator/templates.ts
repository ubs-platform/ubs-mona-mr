import path from 'path';
import { RestApiMethod } from '../rest-doc-extractor/parser/api.data';
import { TypescriptNestUtils } from '../rest-doc-extractor/parser/typescript-utils';

export const ANGULAR_SERVICE_HEADER = `/**
 * This file is auto-generated by MonaXr tool.
 * Generated files can be have mistakes. Please verify the generated code before using.
 * Feel free to feedback any issues to https://github.com/ubs-platform/ubs-mona-mr
 * Generated on: ${new Date().toISOString()}
 */`;

export const ANGULAR_SERVICE_FILE_CORE_HEAD = (className: string, parentPath: string) => `
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class ${className} {
  readonly basePath = '${parentPath}';
  constructor(private http: HttpClient) {}
  
  interceptUrl(url: string): string {
    // you can modify url here if needed
    return this.basePath + url;
  }  
  
`;

export const ANGULAR_SERVICE_NECESSARY_IMPORTS = (workDir: string, parentPackageName: string, methods: RestApiMethod[]) => {
  const importsMap = new Map<string, string[]>();
  methods.forEach(method => {

    if (method.requestBody && method.requestBody.typeName && method.requestBody.importedFrom && typeImportAcceptable(method.requestBody.typeName, method.requestBody.importedFrom)) {

      pootis(importsMap, replaceWorkPathWithPackageName(method.requestBody.importedFrom, workDir, parentPackageName), method.requestBody.typeName);

    }


    if (method.responseType && method.responseType.typeName && method.responseType.importedFrom && typeImportAcceptable(method.responseType.typeName, method.responseType.importedFrom)) {
      const importedFrom = replaceWorkPathWithPackageName(method.responseType.importedFrom, workDir, parentPackageName);

      pootis(importsMap, importedFrom, method.responseType.typeName);
      const typeArguments = method.responseType.typeNode.getTypeArguments();
      typeArguments.forEach(ta => {
        const taTypeName = ta.getText();
        const taImportedFrom =
          TypescriptNestUtils.findImportSource(ta);
        pootis(importsMap, replaceWorkPathWithPackageName(taImportedFrom, workDir, parentPackageName), taTypeName);
      })
    }
  });

  let importStrings = '';
  importsMap.forEach((typeNames, fromPath) => {
    importStrings += `import { ${[...new Set(typeNames)].join(', ')} } from '${fromPath}';\n`;
  });
  return importStrings;

  // collect from parameters too
  // if (method.requestBody &&
  // method.pathParameters.forEach(param => {
  //   if (param.typeName && param.importedFrom) {
  //     importsMap.set(param.typeName, param.importedFrom);
  //   }
  // });
  // method.queryParameters.forEach(param => {
  //   if (param.typeName && param.importedFrom) {
  //     importsMap.set(param.typeName, param.importedFrom);
  //   }
  // });

}

export const ANGULAR_SERVICE_METHOD = (restMethod: RestApiMethod) => {
  const httpMethod = restMethod.methodType.toLowerCase();
  const methodName = restMethod.methodName || allCamelCase(httpMethod, restMethod.path.replace(/[-_\:\/]{1,}([a-zA-Z])/g, (_, p1) => p1.toUpperCase()));
  const url = restMethod.path;
  let bodyType = 'any';
  if (restMethod.requestBody?.typeName == "__type" || restMethod.requestBody?.typeName == "__object" || restMethod.requestBody?.typeName.toLowerCase() == "array") {
    bodyType = restMethod.requestBody.typeExpandedText;
  } else if (restMethod.requestBody?.typeName) {
    bodyType = restMethod.requestBody.typeName || 'any';
  }

  const ngMethodBodyParamString = restMethod.requestBody ? `requestBody: ${bodyType}` : '';
  const ngMethodPathParameters = restMethod.pathParameters.map(param => `${param.parameterName}: ${param.typeName || "any"}`).join(', ');
  const ngMethodQueryParams = restMethod.queryParameters.map(param => `${param.parameterName}: ${param.typeName || "any"}`).join(', ');
  const queryParametersStringInMethod = restMethod.queryParameters.map(param => `\`${param.parameterName}=\${${param.parameterName}}\``).join(' + \'&\' + ');
  const urlPathParameterAltration = restMethod.pathParameters.map(param => `.replace(':${param.parameterName}', ${param.parameterName} + '')`).join('');
  const urlAlteration = (urlPathParameterAltration) + (ngMethodQueryParams ? ` + '?' + ${queryParametersStringInMethod}` : '');

  let responseType = 'any';
  if (restMethod.responseType?.typeName == "__type" || restMethod.responseType?.typeName == "__object" || restMethod.responseType?.typeName.toLowerCase() == "array") {
    responseType = restMethod.responseType.typeExpandedText;
  } else if (restMethod.responseType?.typeName) {
    responseType = restMethod.responseType.typeName || 'any';
  }


  return `
  ${methodName}(${[ngMethodPathParameters, ngMethodQueryParams, ngMethodBodyParamString].filter(x => x).join(', ')}): Observable<${responseType || 'any'}> {
    let urlAltered = this.interceptUrl("${url}")${urlAlteration};

    return this.http.${httpMethod}<${restMethod.responseType?.typeName || 'any'}>(urlAltered${restMethod.requestBody ? ', requestBody' : ''});
  }
`
};

export const ANGULAR_SERVICE_FILE_CORE_TAIL = `
}
`;
function pootis(importsMap: Map<string, string[]>, importedFrom: string, typName: string) {
  if (!importsMap.has(importedFrom)) {
    importsMap.set(importedFrom, []);
  }
  const typeName = typeNameAlone(typName);

  if (!importsMap.get(importedFrom)!.includes(typeName)) {
    importsMap.get(importedFrom)!.push(typeName);
  }
}

function typeNameAlone(tn: String) {
  return tn.replace("[]", "").replace(/<.*>/g, "").replace(/import\(".*"\)\./g, "");
}

function replaceWorkPathWithPackageName(importPath: string, workDir: string, libraryPackageName: string) {
  const workingLibraryName = /libs\/([a-zA-Z-_]*)/g.exec(importPath)?.[1];
  if (importPath.startsWith(workDir) && workingLibraryName) {
    return `${libraryPackageName}/${workingLibraryName}`;
  }
  return importPath;
}

function allCamelCase(...args: string[]): string {
  return args.map((str, index) => {
    if (index === 0) {
      return str.charAt(0).toLowerCase() + str.slice(1);
    } else {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }
  }).join('');

}

function typeImportAcceptable(typeName: string, importedFrom: string) {
  if (typeName === 'any' || typeName === 'void' || typeName === 'string' || typeName === 'number' || typeName === 'boolean' || typeName === 'unknown' || typeName === 'object'
    || typeName === 'Date' || typeName === "__type" || typeName === "__object" || typeName.toLowerCase() === "array"
  ) {
    return false;
  }
  if (importedFrom.startsWith('@nestjs') || importedFrom.includes("apps/") || importedFrom.includes('node_modules/typescript/lib')) {
    return false;
  }
  return true;
}

